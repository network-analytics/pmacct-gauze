use std::ffi::c_int;
use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};

use ipnet::{Ipv4Net, Ipv6Net};

use crate::{
    bgp_afi2family, host_addr, host_addr__bindgen_ty_1, in6_addr, in6_addr__bindgen_ty_1, in_addr,
    prefix, prefix__bindgen_ty_1, AFI_IP, AFI_IP6,
};

impl From<&Ipv4Addr> for in_addr {
    fn from(value: &Ipv4Addr) -> Self {
        in_addr {
            s_addr: value.to_bits().to_be(),
        }
    }
}

impl From<&in_addr> for Ipv4Addr {
    fn from(value: &in_addr) -> Self {
        (*value).into()
    }
}

impl From<in_addr> for Ipv4Addr {
    fn from(value: in_addr) -> Self {
        Ipv4Addr::from_bits(u32::from_be(value.s_addr))
    }
}

impl From<&Ipv6Addr> for in6_addr {
    fn from(value: &Ipv6Addr) -> Self {
        in6_addr {
            __in6_u: in6_addr__bindgen_ty_1 {
                __u6_addr8: value.octets(),
            },
        }
    }
}

impl From<&in6_addr> for Ipv6Addr {
    fn from(value: &in6_addr) -> Self {
        unsafe { Ipv6Addr::from(value.__in6_u.__u6_addr8) }
    }
}

impl From<&Ipv4Net> for prefix {
    fn from(value: &Ipv4Net) -> Self {
        prefix {
            family: unsafe { bgp_afi2family(AFI_IP as c_int) } as u8,
            prefixlen: value.prefix_len(),
            __bindgen_padding_0: 0,
            u: prefix__bindgen_ty_1 {
                prefix4: (&value.network()).into(),
            },
        }
    }
}

impl From<&Ipv6Net> for prefix {
    fn from(value: &Ipv6Net) -> Self {
        prefix {
            family: unsafe { bgp_afi2family(AFI_IP6 as c_int) } as u8,
            prefixlen: value.prefix_len(),
            __bindgen_padding_0: 0,
            u: prefix__bindgen_ty_1 {
                prefix6: (&value.network()).into(),
            },
        }
    }
}

impl From<&Ipv6Addr> for host_addr {
    fn from(value: &Ipv6Addr) -> Self {
        host_addr {
            family: unsafe { bgp_afi2family(AFI_IP6 as c_int) } as u8,
            address: host_addr__bindgen_ty_1 { ipv6: value.into() },
        }
    }
}

impl From<&Ipv4Addr> for host_addr {
    fn from(value: &Ipv4Addr) -> Self {
        host_addr {
            family: unsafe { bgp_afi2family(AFI_IP as c_int) } as u8,
            address: host_addr__bindgen_ty_1 { ipv4: value.into() },
        }
    }
}

impl From<&IpAddr> for host_addr {
    fn from(value: &IpAddr) -> Self {
        match value {
            IpAddr::V4(v4) => v4.into(),
            IpAddr::V6(v6) => v6.into(),
        }
    }
}

#[allow(clippy::derivable_impls)] // this struct definition is autogenerated
impl Default for in_addr {
    fn default() -> Self {
        in_addr { s_addr: 0 }
    }
}

impl Default for in6_addr {
    fn default() -> Self {
        in6_addr {
            __in6_u: in6_addr__bindgen_ty_1 {
                __u6_addr8: [0u8; 16],
            },
        }
    }
}

impl Default for host_addr {
    fn default() -> Self {
        host_addr {
            family: 0,
            // use the ipv6 union variant because, as the largest, it defines the union size
            address: host_addr__bindgen_ty_1 {
                ipv6: in6_addr::default(),
            },
        }
    }
}

impl host_addr {
    pub fn default_ipv4() -> Self {
        host_addr {
            family: unsafe { bgp_afi2family(AFI_IP as c_int) } as u8,
            address: host_addr__bindgen_ty_1 {
                ipv4: in_addr::default(),
            },
        }
    }

    pub fn default_ipv6() -> Self {
        host_addr {
            family: unsafe { bgp_afi2family(AFI_IP6 as c_int) } as u8,
            address: host_addr__bindgen_ty_1 {
                ipv6: in6_addr::default(),
            },
        }
    }
}

#[cfg(test)]
mod tests {
    use std::net::Ipv4Addr;

    use crate::in_addr;

    #[test]
    fn in_addr_from_ipv4_addr() {
        let ip = Ipv4Addr::new(254, 1, 128, 127);
        let _other = in_addr::from(&ip);
    }
}
